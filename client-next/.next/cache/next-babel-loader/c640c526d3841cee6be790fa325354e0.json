{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst {\n  protobuf\n} = require(\"sawtooth-sdk\");\n\nconst fetch = require(\"node-fetch\");\n\nconst createBatchHeader = (signer, transactions) => {\n  const batchHeaderBytes = protobuf.BatchHeader.encode({\n    signerPublicKey: signer.getPublicKey().asHex(),\n    transactionIds: transactions.map(txn => txn.headerSignature)\n  }).finish();\n  return batchHeaderBytes;\n};\n\nconst createBatch = (signer, batchHeaderBytes, transactions) => protobuf.Batch.create({\n  header: batchHeaderBytes,\n  headerSignature: signer.sign(batchHeaderBytes),\n  transactions: transactions\n}); // submit a batch and returns an array of objects with the following fields:\n// link (GET//batch_statuses API link)\n// success\n// id: of the batch\n\n\nconst submitBatch = async batches => {\n  const batchListBytes = protobuf.BatchList.encode({\n    batches\n  }).finish();\n\n  try {\n    if (batchListBytes == null) {\n      //endpoint used to retrieve data from an address in Sawtooth blockchain\n      let response = await fetch(`${process.env.BLOCKCHAIN_ADDR}/state/${this.address}`);\n      let responseJson = await response.json();\n      var data = responseJson.data;\n      var newdata = Buffer.from(data, \"base64\").toString();\n      return newdata;\n    } else {\n      let resp = await fetch(`${process.env.BLOCKCHAIN_ADDR}/batches`, {\n        //endpoint to which we write data in a Sawtooth blockchain\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: batchListBytes\n      });\n      let res = await resp.json();\n      res.success = true;\n      res.id = new URL(res.link).searchParams.get(\"id\");\n      return res;\n    }\n  } catch (error) {\n    console.log(\"error in fetch\", error);\n    return {\n      success: false,\n      error\n    };\n  }\n}; // getting the batch status (deconstruct the response)\n\n\nconst getBatchStatus = async id => {\n  try {\n    const statusReq = await fetch(`${process.env.BLOCKCHAIN_ADDR}/batch_statuses?id=${id}`);\n    const status = await statusReq.json(); // !-- Assuming there's only one transaction to a batch its status.data[0], otherwise: status.data\n\n    return status.data[0];\n  } catch (e) {}\n}; // Gets the transactions that was submitted with the batch\n// and decode the payload to human-readable format\n\n\nconst getSubmittedBatchTransactions = async batch_id => {\n  try {\n    const batchReq = await fetch(`${process.env.BLOCKCHAIN_ADDR}/batches/${batch_id}`, {\n      method: \"GET\"\n    });\n    const batch = await batchReq.json();\n    const transactions = batch.data.transactions.map(transaction => {\n      return _objectSpread(_objectSpread({}, transaction), {}, {\n        payload: Buffer.from(transaction.payload, \"base64\").toString()\n      });\n    });\n    return transactions;\n  } catch (e) {}\n};\n\nmodule.exports = {\n  createBatchHeader,\n  createBatch,\n  submitBatch,\n  getBatchStatus,\n  getSubmittedBatchTransactions\n};","map":{"version":3,"sources":["C:/Users/sagi.levi/DevProjects/sawtooth-dev/client-next/src/BlockchainModules/Batch.js"],"names":["protobuf","require","fetch","createBatchHeader","signer","transactions","batchHeaderBytes","BatchHeader","encode","signerPublicKey","getPublicKey","asHex","transactionIds","map","txn","headerSignature","finish","createBatch","Batch","create","header","sign","submitBatch","batches","batchListBytes","BatchList","response","process","env","BLOCKCHAIN_ADDR","address","responseJson","json","data","newdata","Buffer","from","toString","resp","method","headers","body","res","success","id","URL","link","searchParams","get","error","console","log","getBatchStatus","statusReq","status","e","getSubmittedBatchTransactions","batch_id","batchReq","batch","transaction","payload","module","exports"],"mappings":"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","sourcesContent":["const { protobuf } = require(\"sawtooth-sdk\");\r\nconst fetch = require(\"node-fetch\");\r\n\r\nconst createBatchHeader = (signer, transactions) => {\r\n  const batchHeaderBytes = protobuf.BatchHeader.encode({\r\n    signerPublicKey: signer.getPublicKey().asHex(),\r\n    transactionIds: transactions.map((txn) => txn.headerSignature),\r\n  }).finish();\r\n  return batchHeaderBytes;\r\n};\r\n\r\nconst createBatch = (signer, batchHeaderBytes, transactions) =>\r\n  protobuf.Batch.create({\r\n    header: batchHeaderBytes,\r\n    headerSignature: signer.sign(batchHeaderBytes),\r\n    transactions: transactions,\r\n  });\r\n\r\n// submit a batch and returns an array of objects with the following fields:\r\n// link (GET//batch_statuses API link)\r\n// success\r\n// id: of the batch\r\nconst submitBatch = async (batches) => {\r\n  const batchListBytes = protobuf.BatchList.encode({\r\n    batches,\r\n  }).finish();\r\n\r\n  try {\r\n    if (batchListBytes == null) {\r\n      //endpoint used to retrieve data from an address in Sawtooth blockchain\r\n      let response = await fetch(\r\n        `${process.env.BLOCKCHAIN_ADDR}/state/${this.address}`\r\n      );\r\n      let responseJson = await response.json();\r\n      var data = responseJson.data;\r\n      var newdata = Buffer.from(data, \"base64\").toString();\r\n      return newdata;\r\n    } else {\r\n      let resp = await fetch(`${process.env.BLOCKCHAIN_ADDR}/batches`, {\r\n        //endpoint to which we write data in a Sawtooth blockchain\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/octet-stream\" },\r\n        body: batchListBytes,\r\n      });\r\n      let res = await resp.json();\r\n      res.success = true;\r\n      res.id = new URL(res.link).searchParams.get(\"id\");\r\n      return res;\r\n    }\r\n  } catch (error) {\r\n    console.log(\"error in fetch\", error);\r\n    return {\r\n      success: false,\r\n      error,\r\n    };\r\n  }\r\n};\r\n\r\n// getting the batch status (deconstruct the response)\r\nconst getBatchStatus = async (id) => {\r\n  try {\r\n    const statusReq = await fetch(\r\n      `${process.env.BLOCKCHAIN_ADDR}/batch_statuses?id=${id}`\r\n    );\r\n    const status = await statusReq.json();\r\n    // !-- Assuming there's only one transaction to a batch its status.data[0], otherwise: status.data\r\n    return status.data[0];\r\n  } catch (e) {}\r\n};\r\n\r\n// Gets the transactions that was submitted with the batch\r\n// and decode the payload to human-readable format\r\nconst getSubmittedBatchTransactions = async (batch_id) => {\r\n  try {\r\n    const batchReq = await fetch(\r\n      `${process.env.BLOCKCHAIN_ADDR}/batches/${batch_id}`,\r\n      {\r\n        method: \"GET\",\r\n      }\r\n    );\r\n    const batch = await batchReq.json();\r\n    const transactions = batch.data.transactions.map((transaction) => {\r\n      return {\r\n        ...transaction,\r\n        payload: Buffer.from(transaction.payload, \"base64\").toString(),\r\n      };\r\n    });\r\n    return transactions;\r\n  } catch (e) {}\r\n};\r\n\r\nmodule.exports = {\r\n  createBatchHeader,\r\n  createBatch,\r\n  submitBatch,\r\n  getBatchStatus,\r\n  getSubmittedBatchTransactions,\r\n};\r\n"]},"metadata":{},"sourceType":"script"}