{"ast":null,"code":"var _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _require = require('sawtooth-sdk'),\n    protobuf = _require.protobuf;\n\nvar _require2 = require('text-encoding/lib/encoding'),\n    TextEncoder = _require2.TextEncoder;\n\nvar crypto = require('crypto');\n\nvar createTransactionHeader = function createTransactionHeader(familyName, nameToAddressGen, signer, payload) {\n  var _payload$split = payload.split(','),\n      _payload$split2 = _slicedToArray(_payload$split, 1),\n      name = _payload$split2[0];\n\n  var encoder = new TextEncoder('utf8');\n  var payloadBytes = encoder.encode(payload);\n  var transactionHeaderBytes = protobuf.TransactionHeader.encode({\n    familyName: familyName,\n    familyVersion: '1.0',\n    inputs: [nameToAddressGen(name)],\n    outputs: [nameToAddressGen(name)],\n    signerPublicKey: signer.getPublicKey().asHex(),\n    // In this example, we're signing the batch with the same private key,\n    // but the batch can be signed by another party, in which case, the\n    // public key will need to be associated with that key.\n    batcherPublicKey: signer.getPublicKey().asHex(),\n    // In this example, there are no dependencies.  This list should include\n    // an previous transaction header signatures that must be applied for\n    // this transaction to successfully commit.\n    // For example,\n    // dependencies: ['540a6803971d1880ec73a96cb97815a95d374cbad5d865925e5aa0432fcf1931539afe10310c122c5eaae15df61236079abbf4f258889359c4d175516934484a'],\n    dependencies: [],\n    nonce: '' + Math.random(),\n    payload_encoding: 'utf8',\n    payloadSha512: crypto.createHash('sha512').update(payloadBytes).digest('hex')\n  }).finish();\n  return {\n    transactionHeaderBytes: transactionHeaderBytes,\n    payloadBytes: payloadBytes\n  };\n};\n\nvar createTransaction = function createTransaction(signer, transactionHeaderBytes, payloadBytes) {\n  return protobuf.Transaction.create({\n    header: transactionHeaderBytes,\n    headerSignature: signer.sign(transactionHeaderBytes),\n    payload: payloadBytes\n  });\n};\n\nmodule.exports = {\n  createTransactionHeader: createTransactionHeader,\n  createTransaction: createTransaction\n};","map":{"version":3,"sources":["C:/Users/sagi.levi/DevProjects/sawtooth-dev/client-next/src/BlockchainModules/Transaction.js"],"names":["require","protobuf","TextEncoder","crypto","createTransactionHeader","familyName","nameToAddressGen","signer","payload","split","name","encoder","payloadBytes","encode","transactionHeaderBytes","TransactionHeader","familyVersion","inputs","outputs","signerPublicKey","getPublicKey","asHex","batcherPublicKey","dependencies","nonce","Math","random","payload_encoding","payloadSha512","createHash","update","digest","finish","createTransaction","Transaction","create","header","headerSignature","sign","module","exports"],"mappings":";;eAAqBA,OAAO,CAAC,cAAD,C;IAApBC,Q,YAAAA,Q;;gBACgBD,OAAO,CAAC,4BAAD,C;IAAvBE,W,aAAAA,W;;AACR,IAAMC,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;AAEA,IAAMI,uBAAuB,GAAG,SAA1BA,uBAA0B,CAC9BC,UAD8B,EAE9BC,gBAF8B,EAG9BC,MAH8B,EAI9BC,OAJ8B,EAK3B;AAAA,uBACYA,OAAO,CAACC,KAAR,CAAc,GAAd,CADZ;AAAA;AAAA,MACIC,IADJ;;AAEH,MAAMC,OAAO,GAAG,IAAIT,WAAJ,CAAgB,MAAhB,CAAhB;AACA,MAAMU,YAAY,GAAGD,OAAO,CAACE,MAAR,CAAeL,OAAf,CAArB;AACA,MAAMM,sBAAsB,GAAGb,QAAQ,CAACc,iBAAT,CAA2BF,MAA3B,CAAkC;AAC/DR,IAAAA,UAAU,EAAVA,UAD+D;AAE/DW,IAAAA,aAAa,EAAE,KAFgD;AAG/DC,IAAAA,MAAM,EAAE,CAACX,gBAAgB,CAACI,IAAD,CAAjB,CAHuD;AAI/DQ,IAAAA,OAAO,EAAE,CAACZ,gBAAgB,CAACI,IAAD,CAAjB,CAJsD;AAK/DS,IAAAA,eAAe,EAAEZ,MAAM,CAACa,YAAP,GAAsBC,KAAtB,EAL8C;AAM/D;AACA;AACA;AACAC,IAAAA,gBAAgB,EAAEf,MAAM,CAACa,YAAP,GAAsBC,KAAtB,EAT6C;AAU/D;AACA;AACA;AACA;AACA;AACAE,IAAAA,YAAY,EAAE,EAfiD;AAgB/DC,IAAAA,KAAK,EAAE,KAAKC,IAAI,CAACC,MAAL,EAhBmD;AAiB/DC,IAAAA,gBAAgB,EAAE,MAjB6C;AAkB/DC,IAAAA,aAAa,EAAEzB,MAAM,CAClB0B,UADY,CACD,QADC,EAEZC,MAFY,CAELlB,YAFK,EAGZmB,MAHY,CAGL,KAHK;AAlBgD,GAAlC,EAsB5BC,MAtB4B,EAA/B;AAuBA,SAAO;AAAElB,IAAAA,sBAAsB,EAAtBA,sBAAF;AAA0BF,IAAAA,YAAY,EAAZA;AAA1B,GAAP;AACD,CAjCD;;AAmCA,IAAMqB,iBAAiB,GAAG,SAApBA,iBAAoB,CAAC1B,MAAD,EAASO,sBAAT,EAAiCF,YAAjC,EAAkD;AAC1E,SAAOX,QAAQ,CAACiC,WAAT,CAAqBC,MAArB,CAA4B;AACjCC,IAAAA,MAAM,EAAEtB,sBADyB;AAEjCuB,IAAAA,eAAe,EAAE9B,MAAM,CAAC+B,IAAP,CAAYxB,sBAAZ,CAFgB;AAGjCN,IAAAA,OAAO,EAAEI;AAHwB,GAA5B,CAAP;AAKD,CAND;;AAQA2B,MAAM,CAACC,OAAP,GAAiB;AACfpC,EAAAA,uBAAuB,EAAvBA,uBADe;AAEf6B,EAAAA,iBAAiB,EAAjBA;AAFe,CAAjB","sourcesContent":["const { protobuf } = require('sawtooth-sdk');\r\nconst { TextEncoder } = require('text-encoding/lib/encoding');\r\nconst crypto = require('crypto');\r\n\r\nconst createTransactionHeader = (\r\n  familyName,\r\n  nameToAddressGen,\r\n  signer,\r\n  payload,\r\n) => {\r\n  const [name] = payload.split(',');\r\n  const encoder = new TextEncoder('utf8');\r\n  const payloadBytes = encoder.encode(payload);\r\n  const transactionHeaderBytes = protobuf.TransactionHeader.encode({\r\n    familyName,\r\n    familyVersion: '1.0',\r\n    inputs: [nameToAddressGen(name)],\r\n    outputs: [nameToAddressGen(name)],\r\n    signerPublicKey: signer.getPublicKey().asHex(),\r\n    // In this example, we're signing the batch with the same private key,\r\n    // but the batch can be signed by another party, in which case, the\r\n    // public key will need to be associated with that key.\r\n    batcherPublicKey: signer.getPublicKey().asHex(),\r\n    // In this example, there are no dependencies.  This list should include\r\n    // an previous transaction header signatures that must be applied for\r\n    // this transaction to successfully commit.\r\n    // For example,\r\n    // dependencies: ['540a6803971d1880ec73a96cb97815a95d374cbad5d865925e5aa0432fcf1931539afe10310c122c5eaae15df61236079abbf4f258889359c4d175516934484a'],\r\n    dependencies: [],\r\n    nonce: '' + Math.random(),\r\n    payload_encoding: 'utf8',\r\n    payloadSha512: crypto\r\n      .createHash('sha512')\r\n      .update(payloadBytes)\r\n      .digest('hex'),\r\n  }).finish();\r\n  return { transactionHeaderBytes, payloadBytes };\r\n};\r\n\r\nconst createTransaction = (signer, transactionHeaderBytes, payloadBytes) => {\r\n  return protobuf.Transaction.create({\r\n    header: transactionHeaderBytes,\r\n    headerSignature: signer.sign(transactionHeaderBytes),\r\n    payload: payloadBytes,\r\n  });\r\n};\r\n\r\nmodule.exports = {\r\n  createTransactionHeader,\r\n  createTransaction,\r\n};\r\n"]},"metadata":{},"sourceType":"script"}