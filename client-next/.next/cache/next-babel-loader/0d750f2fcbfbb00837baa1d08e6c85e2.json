{"ast":null,"code":"const {\n  protobuf\n} = require('sawtooth-sdk');\n\nconst {\n  TextEncoder\n} = require('text-encoding/lib/encoding');\n\nconst crypto = require('crypto');\n\nconst createTransactionHeader = (familyName, nameToAddressGen, signer, payload) => {\n  const [name] = payload.split(',');\n  const encoder = new TextEncoder('utf8');\n  const payloadBytes = encoder.encode(payload);\n  const transactionHeaderBytes = protobuf.TransactionHeader.encode({\n    familyName,\n    familyVersion: '1.0',\n    inputs: [nameToAddressGen(name)],\n    outputs: [nameToAddressGen(name)],\n    signerPublicKey: signer.getPublicKey().asHex(),\n    // In this example, we're signing the batch with the same private key,\n    // but the batch can be signed by another party, in which case, the\n    // public key will need to be associated with that key.\n    batcherPublicKey: signer.getPublicKey().asHex(),\n    // In this example, there are no dependencies.  This list should include\n    // an previous transaction header signatures that must be applied for\n    // this transaction to successfully commit.\n    // For example,\n    // dependencies: ['540a6803971d1880ec73a96cb97815a95d374cbad5d865925e5aa0432fcf1931539afe10310c122c5eaae15df61236079abbf4f258889359c4d175516934484a'],\n    dependencies: [],\n    nonce: '' + Math.random(),\n    payload_encoding: 'utf8',\n    payloadSha512: crypto.createHash('sha512').update(payloadBytes).digest('hex')\n  }).finish();\n  return {\n    transactionHeaderBytes,\n    payloadBytes\n  };\n};\n\nconst createTransaction = (signer, transactionHeaderBytes, payloadBytes) => {\n  return protobuf.Transaction.create({\n    header: transactionHeaderBytes,\n    headerSignature: signer.sign(transactionHeaderBytes),\n    payload: payloadBytes\n  });\n};\n\nmodule.exports = {\n  createTransactionHeader,\n  createTransaction\n};","map":{"version":3,"sources":["C:/Users/sagi.levi/DevProjects/sawtooth-dev/client-next/src/BlockchainModules/Transaction.js"],"names":["protobuf","require","TextEncoder","crypto","createTransactionHeader","familyName","nameToAddressGen","signer","payload","name","split","encoder","payloadBytes","encode","transactionHeaderBytes","TransactionHeader","familyVersion","inputs","outputs","signerPublicKey","getPublicKey","asHex","batcherPublicKey","dependencies","nonce","Math","random","payload_encoding","payloadSha512","createHash","update","digest","finish","createTransaction","Transaction","create","header","headerSignature","sign","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAeC,OAAO,CAAC,cAAD,CAA5B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAkBD,OAAO,CAAC,4BAAD,CAA/B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AAEA,MAAMG,uBAAuB,GAAG,CAC9BC,UAD8B,EAE9BC,gBAF8B,EAG9BC,MAH8B,EAI9BC,OAJ8B,KAK3B;AACH,QAAM,CAACC,IAAD,IAASD,OAAO,CAACE,KAAR,CAAc,GAAd,CAAf;AACA,QAAMC,OAAO,GAAG,IAAIT,WAAJ,CAAgB,MAAhB,CAAhB;AACA,QAAMU,YAAY,GAAGD,OAAO,CAACE,MAAR,CAAeL,OAAf,CAArB;AACA,QAAMM,sBAAsB,GAAGd,QAAQ,CAACe,iBAAT,CAA2BF,MAA3B,CAAkC;AAC/DR,IAAAA,UAD+D;AAE/DW,IAAAA,aAAa,EAAE,KAFgD;AAG/DC,IAAAA,MAAM,EAAE,CAACX,gBAAgB,CAACG,IAAD,CAAjB,CAHuD;AAI/DS,IAAAA,OAAO,EAAE,CAACZ,gBAAgB,CAACG,IAAD,CAAjB,CAJsD;AAK/DU,IAAAA,eAAe,EAAEZ,MAAM,CAACa,YAAP,GAAsBC,KAAtB,EAL8C;AAM/D;AACA;AACA;AACAC,IAAAA,gBAAgB,EAAEf,MAAM,CAACa,YAAP,GAAsBC,KAAtB,EAT6C;AAU/D;AACA;AACA;AACA;AACA;AACAE,IAAAA,YAAY,EAAE,EAfiD;AAgB/DC,IAAAA,KAAK,EAAE,KAAKC,IAAI,CAACC,MAAL,EAhBmD;AAiB/DC,IAAAA,gBAAgB,EAAE,MAjB6C;AAkB/DC,IAAAA,aAAa,EAAEzB,MAAM,CAClB0B,UADY,CACD,QADC,EAEZC,MAFY,CAELlB,YAFK,EAGZmB,MAHY,CAGL,KAHK;AAlBgD,GAAlC,EAsB5BC,MAtB4B,EAA/B;AAuBA,SAAO;AAAElB,IAAAA,sBAAF;AAA0BF,IAAAA;AAA1B,GAAP;AACD,CAjCD;;AAmCA,MAAMqB,iBAAiB,GAAG,CAAC1B,MAAD,EAASO,sBAAT,EAAiCF,YAAjC,KAAkD;AAC1E,SAAOZ,QAAQ,CAACkC,WAAT,CAAqBC,MAArB,CAA4B;AACjCC,IAAAA,MAAM,EAAEtB,sBADyB;AAEjCuB,IAAAA,eAAe,EAAE9B,MAAM,CAAC+B,IAAP,CAAYxB,sBAAZ,CAFgB;AAGjCN,IAAAA,OAAO,EAAEI;AAHwB,GAA5B,CAAP;AAKD,CAND;;AAQA2B,MAAM,CAACC,OAAP,GAAiB;AACfpC,EAAAA,uBADe;AAEf6B,EAAAA;AAFe,CAAjB","sourcesContent":["const { protobuf } = require('sawtooth-sdk');\r\nconst { TextEncoder } = require('text-encoding/lib/encoding');\r\nconst crypto = require('crypto');\r\n\r\nconst createTransactionHeader = (\r\n  familyName,\r\n  nameToAddressGen,\r\n  signer,\r\n  payload,\r\n) => {\r\n  const [name] = payload.split(',');\r\n  const encoder = new TextEncoder('utf8');\r\n  const payloadBytes = encoder.encode(payload);\r\n  const transactionHeaderBytes = protobuf.TransactionHeader.encode({\r\n    familyName,\r\n    familyVersion: '1.0',\r\n    inputs: [nameToAddressGen(name)],\r\n    outputs: [nameToAddressGen(name)],\r\n    signerPublicKey: signer.getPublicKey().asHex(),\r\n    // In this example, we're signing the batch with the same private key,\r\n    // but the batch can be signed by another party, in which case, the\r\n    // public key will need to be associated with that key.\r\n    batcherPublicKey: signer.getPublicKey().asHex(),\r\n    // In this example, there are no dependencies.  This list should include\r\n    // an previous transaction header signatures that must be applied for\r\n    // this transaction to successfully commit.\r\n    // For example,\r\n    // dependencies: ['540a6803971d1880ec73a96cb97815a95d374cbad5d865925e5aa0432fcf1931539afe10310c122c5eaae15df61236079abbf4f258889359c4d175516934484a'],\r\n    dependencies: [],\r\n    nonce: '' + Math.random(),\r\n    payload_encoding: 'utf8',\r\n    payloadSha512: crypto\r\n      .createHash('sha512')\r\n      .update(payloadBytes)\r\n      .digest('hex'),\r\n  }).finish();\r\n  return { transactionHeaderBytes, payloadBytes };\r\n};\r\n\r\nconst createTransaction = (signer, transactionHeaderBytes, payloadBytes) => {\r\n  return protobuf.Transaction.create({\r\n    header: transactionHeaderBytes,\r\n    headerSignature: signer.sign(transactionHeaderBytes),\r\n    payload: payloadBytes,\r\n  });\r\n};\r\n\r\nmodule.exports = {\r\n  createTransactionHeader,\r\n  createTransaction,\r\n};\r\n"]},"metadata":{},"sourceType":"script"}