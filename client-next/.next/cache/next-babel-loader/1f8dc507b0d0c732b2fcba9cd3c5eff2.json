{"ast":null,"code":"var _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\n\nvar _this = this;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar _require = require(\"sawtooth-sdk\"),\n    protobuf = _require.protobuf;\n\nvar fetch = require(\"node-fetch\");\n\nvar createBatchHeader = function createBatchHeader(signer, transactions) {\n  var batchHeaderBytes = protobuf.BatchHeader.encode({\n    signerPublicKey: signer.getPublicKey().asHex(),\n    transactionIds: transactions.map(function (txn) {\n      return txn.headerSignature;\n    })\n  }).finish();\n  return batchHeaderBytes;\n};\n\nvar createBatch = function createBatch(signer, batchHeaderBytes, transactions) {\n  return protobuf.Batch.create({\n    header: batchHeaderBytes,\n    headerSignature: signer.sign(batchHeaderBytes),\n    transactions: transactions\n  });\n}; // submit a batch and returns an array of objects with the following fields:\n// link (GET//batch_statuses API link)\n// success\n// id: of the batch\n\n\nvar submitBatch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(batches) {\n    var batchListBytes, response, responseJson, data, newdata, resp, res;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            batchListBytes = protobuf.BatchList.encode({\n              batches: batches\n            }).finish();\n            _context.prev = 1;\n\n            if (!(batchListBytes == null)) {\n              _context.next = 14;\n              break;\n            }\n\n            _context.next = 5;\n            return fetch(\"\".concat(process.env.BLOCKCHAIN_ADDR, \"/state/\").concat(_this.address));\n\n          case 5:\n            response = _context.sent;\n            _context.next = 8;\n            return response.json();\n\n          case 8:\n            responseJson = _context.sent;\n            data = responseJson.data;\n            newdata = Buffer.from(data, \"base64\").toString();\n            return _context.abrupt(\"return\", newdata);\n\n          case 14:\n            _context.next = 16;\n            return fetch(\"\".concat(process.env.BLOCKCHAIN_ADDR, \"/batches\"), {\n              //endpoint to which we write data in a Sawtooth blockchain\n              method: \"POST\",\n              headers: {\n                \"Content-Type\": \"application/octet-stream\"\n              },\n              body: batchListBytes\n            });\n\n          case 16:\n            resp = _context.sent;\n            _context.next = 19;\n            return resp.json();\n\n          case 19:\n            res = _context.sent;\n            res.success = true;\n            res.id = new URL(res.link).searchParams.get(\"id\");\n            return _context.abrupt(\"return\", res);\n\n          case 23:\n            _context.next = 29;\n            break;\n\n          case 25:\n            _context.prev = 25;\n            _context.t0 = _context[\"catch\"](1);\n            console.log(\"error in fetch\", _context.t0);\n            return _context.abrupt(\"return\", {\n              success: false,\n              error: _context.t0\n            });\n\n          case 29:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 25]]);\n  }));\n\n  return function submitBatch(_x) {\n    return _ref.apply(this, arguments);\n  };\n}(); // getting the batch status (deconstruct the response)\n\n\nvar getBatchStatus = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(id) {\n    var statusReq, status;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return fetch(\"\".concat(process.env.BLOCKCHAIN_ADDR, \"/batch_statuses?id=\").concat(id));\n\n          case 3:\n            statusReq = _context2.sent;\n            _context2.next = 6;\n            return statusReq.json();\n\n          case 6:\n            status = _context2.sent;\n            return _context2.abrupt(\"return\", status.data[0]);\n\n          case 10:\n            _context2.prev = 10;\n            _context2.t0 = _context2[\"catch\"](0);\n\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 10]]);\n  }));\n\n  return function getBatchStatus(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // Gets the transactions that was submitted with the batch\n// and decode the payload to human-readable format\n\n\nvar getSubmittedBatchTransactions = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(batch_id) {\n    var batchReq, batch, transactions;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return fetch(\"\".concat(process.env.BLOCKCHAIN_ADDR, \"/batches/\").concat(batch_id), {\n              method: \"GET\"\n            });\n\n          case 3:\n            batchReq = _context3.sent;\n            _context3.next = 6;\n            return batchReq.json();\n\n          case 6:\n            batch = _context3.sent;\n            transactions = batch.data.transactions.map(function (transaction) {\n              return _objectSpread(_objectSpread({}, transaction), {}, {\n                payload: Buffer.from(transaction.payload, \"base64\").toString()\n              });\n            });\n            return _context3.abrupt(\"return\", transactions);\n\n          case 11:\n            _context3.prev = 11;\n            _context3.t0 = _context3[\"catch\"](0);\n\n          case 13:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 11]]);\n  }));\n\n  return function getSubmittedBatchTransactions(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nmodule.exports = {\n  createBatchHeader: createBatchHeader,\n  createBatch: createBatch,\n  submitBatch: submitBatch,\n  getBatchStatus: getBatchStatus,\n  getSubmittedBatchTransactions: getSubmittedBatchTransactions\n};","map":{"version":3,"sources":["C:/Users/sagi.levi/DevProjects/sawtooth-dev/client-next/src/BlockchainModules/Batch.js"],"names":["require","protobuf","fetch","createBatchHeader","signer","transactions","batchHeaderBytes","BatchHeader","encode","signerPublicKey","getPublicKey","asHex","transactionIds","map","txn","headerSignature","finish","createBatch","Batch","create","header","sign","submitBatch","batches","batchListBytes","BatchList","process","env","BLOCKCHAIN_ADDR","address","response","json","responseJson","data","newdata","Buffer","from","toString","method","headers","body","resp","res","success","id","URL","link","searchParams","get","console","log","error","getBatchStatus","statusReq","status","getSubmittedBatchTransactions","batch_id","batchReq","batch","transaction","payload","module","exports"],"mappings":"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","sourcesContent":["const { protobuf } = require(\"sawtooth-sdk\");\r\nconst fetch = require(\"node-fetch\");\r\n\r\nconst createBatchHeader = (signer, transactions) => {\r\n  const batchHeaderBytes = protobuf.BatchHeader.encode({\r\n    signerPublicKey: signer.getPublicKey().asHex(),\r\n    transactionIds: transactions.map((txn) => txn.headerSignature),\r\n  }).finish();\r\n  return batchHeaderBytes;\r\n};\r\n\r\nconst createBatch = (signer, batchHeaderBytes, transactions) =>\r\n  protobuf.Batch.create({\r\n    header: batchHeaderBytes,\r\n    headerSignature: signer.sign(batchHeaderBytes),\r\n    transactions: transactions,\r\n  });\r\n\r\n// submit a batch and returns an array of objects with the following fields:\r\n// link (GET//batch_statuses API link)\r\n// success\r\n// id: of the batch\r\nconst submitBatch = async (batches) => {\r\n  const batchListBytes = protobuf.BatchList.encode({\r\n    batches,\r\n  }).finish();\r\n\r\n  try {\r\n    if (batchListBytes == null) {\r\n      //endpoint used to retrieve data from an address in Sawtooth blockchain\r\n      let response = await fetch(\r\n        `${process.env.BLOCKCHAIN_ADDR}/state/${this.address}`\r\n      );\r\n      let responseJson = await response.json();\r\n      var data = responseJson.data;\r\n      var newdata = Buffer.from(data, \"base64\").toString();\r\n      return newdata;\r\n    } else {\r\n      let resp = await fetch(`${process.env.BLOCKCHAIN_ADDR}/batches`, {\r\n        //endpoint to which we write data in a Sawtooth blockchain\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/octet-stream\" },\r\n        body: batchListBytes,\r\n      });\r\n      let res = await resp.json();\r\n      res.success = true;\r\n      res.id = new URL(res.link).searchParams.get(\"id\");\r\n      return res;\r\n    }\r\n  } catch (error) {\r\n    console.log(\"error in fetch\", error);\r\n    return {\r\n      success: false,\r\n      error,\r\n    };\r\n  }\r\n};\r\n\r\n// getting the batch status (deconstruct the response)\r\nconst getBatchStatus = async (id) => {\r\n  try {\r\n    const statusReq = await fetch(\r\n      `${process.env.BLOCKCHAIN_ADDR}/batch_statuses?id=${id}`\r\n    );\r\n    const status = await statusReq.json();\r\n    // !-- Assuming there's only one transaction to a batch its status.data[0], otherwise: status.data\r\n    return status.data[0];\r\n  } catch (e) {}\r\n};\r\n\r\n// Gets the transactions that was submitted with the batch\r\n// and decode the payload to human-readable format\r\nconst getSubmittedBatchTransactions = async (batch_id) => {\r\n  try {\r\n    const batchReq = await fetch(\r\n      `${process.env.BLOCKCHAIN_ADDR}/batches/${batch_id}`,\r\n      {\r\n        method: \"GET\",\r\n      }\r\n    );\r\n    const batch = await batchReq.json();\r\n    const transactions = batch.data.transactions.map((transaction) => {\r\n      return {\r\n        ...transaction,\r\n        payload: Buffer.from(transaction.payload, \"base64\").toString(),\r\n      };\r\n    });\r\n    return transactions;\r\n  } catch (e) {}\r\n};\r\n\r\nmodule.exports = {\r\n  createBatchHeader,\r\n  createBatch,\r\n  submitBatch,\r\n  getBatchStatus,\r\n  getSubmittedBatchTransactions,\r\n};\r\n"]},"metadata":{},"sourceType":"script"}